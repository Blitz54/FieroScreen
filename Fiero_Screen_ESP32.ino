//  3.5 inch 9488 TFT for Pontiac Fiero to replace 
//  the fuel gauge and the coolant gauge, as well as
//  add a washer fluid level, and a gear selection.
//  Node32S
#include <SPI.h>
#include <TFT_eSPI.h> // Hardware-specific library ILI9488_DRIVER Setup21_ILI9488
#include <DallasTemperature.h>  // Temp gauge
#include <OneWire.h>
#include <Wire.h>
#include "esp_system.h" 
#include "freertos/semphr.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "Free_Fonts.h"
#include "fierologo.h"
#include <TJpg_Decoder.h>
#include "esp_adc/adc_cali_scheme.h"
#include "esp_adc/adc_cali.h"
#include <ezButton.h>
#include "MultiMap.h"

TFT_eSPI tft = TFT_eSPI();       // Invoke custom library

#define BLACK   0x0000
#define BGCOLOR   0x1000
#define RED     0xF800
#define WHITE   0xFFFF
#define ORANGE   0xFC00

#define DATA_PIN 14
#define SENSOR_RESOLUTION 9
#define SENSOR_INDEX 0
//USE THESE TO SHRINK TASK SIZE IF NEEDED, UNLIKELY BUT NICE TO LEARN
//#define INCLUDE_uxTaskGetStackHighWaterMark 1
//Serial.println(uxTaskGetStackHighWaterMark(NULL));
OneWire oneWire(DATA_PIN);
DallasTemperature sensors(&oneWire);
DeviceAddress sensorDeviceAddress;

// 'FieroDrawing', 60x100px
const unsigned char FieroDrawing [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xf0, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0xff, 0xf0, 0x01, 0x00, 0x00, 
	0x00, 0x08, 0xff, 0x00, 0x0f, 0xf1, 0x00, 0x00, 0x00, 0x13, 0x04, 0x00, 0x02, 0x0c, 0x80, 0x00, 
	0x00, 0x14, 0xf4, 0x00, 0x02, 0xf2, 0x80, 0x00, 0x00, 0x15, 0x14, 0x00, 0x02, 0x8a, 0x80, 0x00, 
	0x00, 0x15, 0x14, 0x00, 0x02, 0x8a, 0x80, 0x00, 0x00, 0x15, 0x14, 0x00, 0x02, 0x8a, 0x80, 0x00, 
	0x00, 0x15, 0x14, 0x00, 0x02, 0x8a, 0x80, 0x00, 0x00, 0x15, 0xf4, 0x00, 0x02, 0xfa, 0x80, 0x00, 
	0x00, 0x24, 0x04, 0x00, 0x02, 0x02, 0x40, 0x00, 0x00, 0x24, 0x04, 0x00, 0x02, 0x02, 0x40, 0x00, 
	0x00, 0x24, 0x04, 0x00, 0x02, 0x02, 0x40, 0x00, 0x00, 0x24, 0x0c, 0x00, 0x03, 0x02, 0x40, 0x00, 
	0x00, 0x24, 0x08, 0x00, 0x01, 0x02, 0x40, 0x00, 0x00, 0x24, 0x08, 0x00, 0x01, 0x02, 0x40, 0x00, 
	0x00, 0x44, 0x08, 0x00, 0x01, 0x02, 0x20, 0x00, 0x00, 0x44, 0x08, 0x00, 0x01, 0x02, 0x20, 0x00, 
	0x00, 0x44, 0x08, 0x00, 0x01, 0x02, 0x20, 0x00, 0x00, 0x48, 0x08, 0x00, 0x01, 0x01, 0x20, 0x00, 
	0x00, 0x48, 0x08, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x48, 0x08, 0x00, 0x01, 0x01, 0x20, 0x00, 
	0x00, 0x48, 0x08, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x48, 0x08, 0x00, 0x01, 0x01, 0x20, 0x00, 
	0x00, 0x48, 0x08, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x48, 0x08, 0x00, 0x01, 0x01, 0x20, 0x00, 
	0x00, 0x48, 0x0f, 0xff, 0xff, 0x01, 0x20, 0x00, 0x00, 0x48, 0xf8, 0x00, 0x01, 0xf1, 0x20, 0x00, 
	0x00, 0xc8, 0x80, 0x00, 0x00, 0x11, 0x30, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x0d, 0x10, 0x00, 
	0x00, 0x8c, 0x00, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x01, 0x90, 0x00, 
	0x00, 0xb8, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0xec, 0x00, 0x00, 0x00, 0x03, 0x70, 0x00, 
	0x00, 0x8c, 0x00, 0x00, 0x00, 0x03, 0x10, 0x00, 0x01, 0x8c, 0x00, 0x00, 0x00, 0x03, 0x18, 0x00, 
	0x01, 0x1a, 0x00, 0x00, 0x00, 0x05, 0x88, 0x00, 0x01, 0xfa, 0x00, 0x00, 0x00, 0x05, 0xf8, 0x00, 
	0x00, 0xaa, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00, 0xa5, 0x00, 0x00, 0x00, 0x0a, 0x50, 0x00, 
	0x00, 0xa5, 0x00, 0x00, 0x00, 0x0a, 0x50, 0x00, 0x00, 0xa5, 0x00, 0x00, 0x00, 0x0a, 0x50, 0x00, 
	0x00, 0xa2, 0x80, 0x00, 0x00, 0x14, 0x50, 0x00, 0x00, 0xa2, 0x87, 0xff, 0xfe, 0x14, 0x50, 0x00, 
	0x00, 0xa1, 0x78, 0x00, 0x01, 0xe8, 0x50, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00, 0x08, 0x50, 0x00, 
	0x00, 0xa1, 0x00, 0x00, 0x00, 0x08, 0x50, 0x00, 0x00, 0xa1, 0x3f, 0xff, 0xff, 0xc8, 0x50, 0x00, 
	0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 
	0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 
	0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 
	0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 
	0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 0x00, 0xbf, 0x40, 0x00, 0x00, 0x2f, 0xd0, 0x00, 
	0x00, 0xa1, 0x40, 0x00, 0x00, 0x28, 0x50, 0x00, 0x00, 0xa1, 0x3f, 0xff, 0xff, 0xc8, 0x50, 0x00, 
	0x00, 0xa1, 0x00, 0x00, 0x00, 0x08, 0x50, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00, 0x08, 0x50, 0x00, 
	0x00, 0xa1, 0x00, 0x00, 0x00, 0x08, 0x50, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00, 0x08, 0x50, 0x00, 
	0x00, 0xa1, 0x3f, 0xff, 0xff, 0xc8, 0x50, 0x00, 0x00, 0xa2, 0x4c, 0x00, 0x03, 0x24, 0x50, 0x00, 
	0x00, 0xa2, 0x8c, 0x00, 0x03, 0x14, 0x50, 0x00, 0x00, 0xa2, 0x8c, 0x00, 0x03, 0x14, 0x50, 0x00, 
	0x00, 0xa2, 0x8c, 0x00, 0x03, 0x14, 0x50, 0x00, 0x00, 0xa2, 0x8c, 0x00, 0x03, 0x14, 0x50, 0x00, 
	0x00, 0xa5, 0x0c, 0x00, 0x03, 0x0a, 0x50, 0x00, 0x00, 0xa5, 0x0c, 0x00, 0x03, 0x0a, 0x50, 0x00, 
	0x00, 0xa5, 0x0c, 0x00, 0x03, 0x0a, 0x50, 0x00, 0x00, 0x95, 0x0c, 0x00, 0x03, 0x0a, 0x90, 0x00, 
	0x00, 0x95, 0x0c, 0x00, 0x03, 0x0a, 0x90, 0x00, 0x00, 0x95, 0x0c, 0x00, 0x03, 0x0a, 0x90, 0x00, 
	0x00, 0x8b, 0xfc, 0x00, 0x03, 0xfd, 0x10, 0x00, 0x00, 0x82, 0x0c, 0x00, 0x03, 0x04, 0x10, 0x00, 
	0x00, 0x82, 0x0c, 0x00, 0x03, 0x04, 0x10, 0x00, 0x00, 0x82, 0x0c, 0x00, 0x03, 0x04, 0x10, 0x00, 
	0x00, 0x82, 0x0c, 0x00, 0x03, 0x04, 0x10, 0x00, 0x00, 0x86, 0x0c, 0x00, 0x03, 0x06, 0x10, 0x00, 
	0x00, 0x84, 0x0c, 0x00, 0x03, 0x02, 0x10, 0x00, 0x00, 0x84, 0x0c, 0x00, 0x03, 0x02, 0x10, 0x00, 
	0x00, 0x84, 0x0c, 0x00, 0x03, 0x02, 0x10, 0x00, 0x00, 0x9f, 0xfe, 0x00, 0x07, 0xff, 0x90, 0x00, 
	0x00, 0x90, 0x01, 0xff, 0xf8, 0x00, 0x90, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 
	0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 
	0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x01, 0xa0, 0x00, 
	0x00, 0x46, 0x00, 0x00, 0x00, 0x06, 0x20, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 
	0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'wiper', 50x50px
const unsigned char wiper [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x07, 0xc8, 0x09, 
	0xf0, 0x00, 0x00, 0x00, 0x0f, 0xce, 0x1d, 0xfc, 0x00, 0x00, 0x00, 0x1f, 0x0f, 0x3c, 0x3c, 0x00, 
	0x00, 0x00, 0x0c, 0x07, 0xf8, 0x08, 0x00, 0x00, 0x00, 0x60, 0x03, 0xf0, 0x01, 0x00, 0x00, 0x00, 
	0x70, 0x01, 0xe0, 0x03, 0x80, 0x00, 0x00, 0x70, 0x01, 0xc0, 0x03, 0x80, 0x00, 0x00, 0xe0, 0x00, 
	0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x7f, 0xc1, 0xc0, 0xff, 0x00, 0x00, 0x01, 0xfc, 
	0x01, 0xc0, 0x1f, 0xc0, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x0f, 0xc0, 0x00, 0x00, 
	0x00, 0xf8, 0x00, 0x1f, 0x00, 0x01, 0xc0, 0x00, 0x3c, 0x00, 0x3c, 0x00, 0x01, 0xc0, 0x00, 0x1f, 
	0x00, 0x78, 0x0c, 0x01, 0xc0, 0x00, 0x0f, 0x80, 0xf0, 0x1e, 0x01, 0xc0, 0x00, 0x03, 0xc0, 0xf0, 
	0x0e, 0x01, 0xc0, 0x00, 0x03, 0xc0, 0x78, 0x07, 0x01, 0xc0, 0x00, 0x07, 0x80, 0x3c, 0x07, 0x80, 
	0xc0, 0x00, 0x0f, 0x00, 0x1e, 0x03, 0x80, 0x00, 0x00, 0x1e, 0x00, 0x0f, 0x01, 0xc0, 0xc0, 0x00, 
	0x3c, 0x00, 0x07, 0x81, 0xe1, 0xc0, 0x00, 0x78, 0x00, 0x03, 0xc0, 0xe1, 0xc0, 0x00, 0xf0, 0x00, 
	0x01, 0xe0, 0xf1, 0xc0, 0x01, 0xe0, 0x00, 0x00, 0xf0, 0x70, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x78, 
	0x38, 0x00, 0x07, 0x80, 0x00, 0x00, 0x3c, 0x3f, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x1e, 0x1f, 0xfe, 
	0x1e, 0x00, 0x00, 0x00, 0x0f, 0x7f, 0xff, 0x3c, 0x00, 0x00, 0x00, 0x07, 0xff, 0x0f, 0xf8, 0x00, 
	0x00, 0x00, 0x03, 0xe7, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xc7, 0xc0, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x83, 0xe0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
	0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'gaspump', 30x30px
const unsigned char gaspump [] PROGMEM = {
	0x1f, 0xff, 0xe0, 0x00, 0x3f, 0xff, 0xe0, 0x00, 0x3c, 0x00, 0xf6, 0x00, 0x38, 0x00, 0x7f, 0x00, 
	0x38, 0x00, 0x7f, 0x80, 0x38, 0x00, 0x77, 0xc0, 0x38, 0x00, 0x73, 0xe0, 0x38, 0x00, 0x71, 0xf0, 
	0x38, 0x00, 0x70, 0xf8, 0x38, 0x00, 0x70, 0xfc, 0x38, 0x00, 0x70, 0xfc, 0x3f, 0xff, 0xf0, 0xfc, 
	0x3f, 0xff, 0xf0, 0xfc, 0x3f, 0xff, 0xf0, 0x7c, 0x3f, 0xff, 0xf8, 0x3c, 0x3f, 0xff, 0xfe, 0x1c, 
	0x3f, 0xff, 0xff, 0x0c, 0x3f, 0xff, 0xff, 0x0c, 0x3f, 0xff, 0xf3, 0x8c, 0x3f, 0xff, 0xf3, 0x8c, 
	0x3f, 0xff, 0xf3, 0x9c, 0x3f, 0xff, 0xf3, 0x9c, 0x3f, 0xff, 0xf3, 0x9c, 0x3f, 0xff, 0xf3, 0x9c, 
	0x3f, 0xff, 0xf3, 0x9c, 0x3f, 0xff, 0xf3, 0xf8, 0x3f, 0xff, 0xf1, 0xf8, 0x3f, 0xff, 0xf0, 0xf0, 
	0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xfc, 0x00
};
// 'coolanttemp', 35x30px
const unsigned char coolanttemp [] PROGMEM = {
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 
	0x01, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x01, 
	0xff, 0xe0, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xc0, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 
	0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 
	0x03, 0xf8, 0x00, 0x00, 0x0c, 0x07, 0xfc, 0x06, 0x00, 0x3f, 0x17, 0xfd, 0x1f, 0x80, 0xff, 0xf7, 
	0xfd, 0xff, 0xe0, 0xf3, 0xf3, 0xf9, 0xf9, 0xe0, 0xe1, 0xe1, 0xf0, 0xf0, 0xe0, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x3f, 0x1f, 0x1f, 0x1f, 0x80, 0x1f, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xff, 0xff, 0xff, 
	0x80, 0x01, 0xf1, 0xf1, 0xf0, 0x00
};
bool tft_output(int16_t x, int16_t y, uint16_t w, uint16_t h, uint16_t* bitmap)
{
  // Stop further decoding as image is running off bottom of screen
  if ( y >= tft.height() ) return 0;

  // This function will clip the image block rendering automatically at the TFT boundaries
  tft.pushImage(x, y, w, h, bitmap);

  // Return 1 to decode next block
  return 1;
}

//int datascreen = 0; //for potentially a button with different screens for data
bool MainButton; //main button
const int LEDPin = 22;
const int LEDFreq = 5000;
const int LEDRes = 8;
int LEDDuty = 0; //0 - 255. 0 Is grounded, hence LED brightest because PNP transistor is on fully.

ezButton GearBut1(16);
ezButton GearBut2(17);
ezButton GearBut3(25);
ezButton GearBut4(26);
ezButton GearButRev(13);

int GEAR = 1;
unsigned long geartimer = millis();

int LastPrintWARN;
bool ColdWeatherWarnedAlready = false;

const int WasherLVL = 27; //pin 27
bool washerlow = false;
int WasherArray [16] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}; //starts full
int WasherIndex = 0;
int WasherCount = 0;

int CarVoltagePin = 33;

float average;

const int FuelR1 = 200;
float FuelR2 = 0;
float FUELOHMTEST;
float FuelTotal;
float FuelAverage;
float FuelCurrent;
int FuelArray [32]; //averaging readings
int FuelBarSIZE;
int FuelIndex = 0;
const int FuelPin = 32; //Fuel and coolant are on ADC1, so that I can use bluetooth as ADC2 can't be used with bluetooth on.

int CoolantR1 = 1000;
float CoolantTotal;
float CoolantAverage;
float CoolantCurrent;
int CoolantArray [32]; //averaging readings
int CoolantBarSIZE;
int CoolantIndex = 0;
const int CoolantPin = 35; // MIGHT BE FRIED, OLD MCU NOT WORKING AND RED LIGHT

float FuelValuesIN [] = {640,752,809,891,960,1040,1107,1171,1231,1288,1342};//lowest reading SHOULD be 628, but increased it a little so that the fuel shows empty near 2 ohms.
float FuelValuesOUT [] = {0,21,42,63,84,105,126,147,168,189,210};

//array for coolant readings. First one is analogReadMilliVolts, second one is Fahrenheit. 1k R1 and 47ohm R2 inline with sensor.
float CoolantValuesIN [] = {253,279,318,344,381,441,452,509,595,676,742,857,892, 953,1049,1212,1336,1463,1754,1966,2172,2449,2790,2863,2943,2998,3039,3098,3129};
float CoolantValuesOUT [29] = {290,280,270,260,250,240,230,220,210,200,190,180,175,170,160,150,140,130,110,100,90,70,40,30,20,10,0,-20,-40};//17 readings, from 100 to 260

float temperatureInCelsius = sensors.getTempCByIndex(SENSOR_INDEX);
float temperatureInFahrenheit = sensors.getTempFByIndex(SENSOR_INDEX);
char currenttemp [9];
float oldtemp = 0;
char tempstring [12];

void showmsgXY(int x, int y, uint8_t s, int w, const GFXfont *f, const char *msg)
{
  tft.setTextPadding(w);
  tft.setTextSize(s);
  tft.setTextColor(RED, BGCOLOR);
  tft.setFreeFont(f);
  tft.drawString(msg, x, y);
}

SemaphoreHandle_t  LCDMutex; //mutex for printing to screen. If two tasks print at same time screen gets corrupted

TaskHandle_t PrintCRNTGear;
TaskHandle_t TempSensor;
TaskHandle_t WasherTask;
TaskHandle_t Fuel;
TaskHandle_t Coolant;
TaskHandle_t WarningTask;
TaskHandle_t TPMS;

void setup(void)
{
  TJpgDec.setCallback(tft_output);
  tft.setSwapBytes(true);
  tft.init();
  tft.fillScreen(BGCOLOR);
  tft.setRotation(2); //2 is 180, 0 is default
  TJpgDec.drawJpg(0, 0, fierologo, sizeof(fierologo));
  //delay(200);//led delayed so white flash doesnt happen on boot. Not needed if using PWM.
  ledcAttach(LEDPin, LEDFreq, LEDRes);
  ledcWrite(LEDPin, LEDDuty);
  Serial.begin(115200); // For debug
  sensors.begin();
  analogReadResolution(12);
  sensors.getAddress(sensorDeviceAddress, 0);
  sensors.setResolution(sensorDeviceAddress, SENSOR_RESOLUTION);
  pinMode(27, INPUT_PULLUP); //Arduino Internal Resistor 10K Washer Level
  GearBut1.setDebounceTime(50); // all EzPins are pulled up with internal resistor
  GearBut2.setDebounceTime(50);
  GearBut3.setDebounceTime(50);
  GearBut4.setDebounceTime(50);
  GearButRev.setDebounceTime(50); // set debounce time to 50 milliseconds for gear buttons
  for (int i = 0; i < 32; i++) //read fuel level on start
    {
    FuelArray[i] = (analogReadMilliVolts(FuelPin)*0.977);//calibrate millivolt reading by multiplying
    FuelTotal += (analogReadMilliVolts(FuelPin)*0.977);
    }
  FuelAverage = FuelTotal / 32;
  FuelCurrent = FuelAverage;
  for (int i = 0; i < 32; i++)
    {
    CoolantArray[i] = (analogReadMilliVolts(CoolantPin)*0.977);
    CoolantTotal += (analogReadMilliVolts(CoolantPin)*0.977);
    }
  CoolantAverage = CoolantTotal / 32;
  CoolantCurrent = CoolantAverage;
  vTaskDelay(2400);
  tft.setTextDatum(CC_DATUM);
  tft.setTextColor(RED, BGCOLOR, true);
  ledcDetach(LEDPin);//disable LCD backlight temporarily to erase Fiero logo and print new stuff
  pinMode(LEDPin, INPUT);
  tft.fillScreen(BGCOLOR);
  tft.fillRect(270, 200, 45, 230, RED); //fuel bar
  tft.fillRect(5, 200, 45, 230, RED); // temp bar
  tft.fillRect(275, 205, 35, 220, BGCOLOR); //fuel bar bg
  tft.fillRect(10, 205, 35, 220, BGCOLOR); //temp bar bg
  tft.fillRect(270, 255, 8, 6, RED); //top fuel bar
  tft.fillRect(270, 312, 8, 6, RED); //half fuel bar
  tft.fillRect(270, 369, 8, 6, RED); //bottom fuel bar   
  tft.fillRect(42, 255, 8, 6, RED); //top temp bar   
  tft.fillRect(0, 160, 320, 5, RED); //horizontal bar
  tft.drawBitmap(50, 25, FieroDrawing, 60, 100, RED);
  tft.fillRect(10, 40, 40, 3, RED);//psi FL
  tft.fillRect(110, 40, 40, 3, RED);//psi FR
  tft.fillRect(10, 105, 40, 3, RED);//psi RL
  tft.fillRect(110, 105, 40, 3, RED);//psi RR
  showmsgXY(30, 25, 1, 20, FSS12, "30");//FL
  showmsgXY(130, 25, 1, 20, FSS12, "30");//FR
  showmsgXY(30, 90, 1, 20, FSS12, "30");//RL
  showmsgXY(130, 90, 1, 20, FSS12, "30");//RR
  tft.drawBitmap(230, 300, gaspump, 30, 30, RED);
  tft.fillTriangle(215, 315, 225, 325, 225, 305, RED); //triangle for fuel cap
  tft.drawBitmap(60, 300, coolanttemp, 35, 30, RED);
  showmsgXY(78, 140, 1, 20, FSSB12, "PSI");
  showmsgXY(250, 220, 1, 20, FSSB12, "F");
  showmsgXY(250, 405, 1, 20, FSSB12, "E");
  showmsgXY(70, 220, 1, 20, FSSB12, "H");
  showmsgXY(70, 405, 1, 20, FSSB12, "C");
  showmsgXY(160, 310, 2, 100, FSSB24, "N");
  tft.fillTriangle(65, 480, 85, 440, 105, 480, RED); //outside temp section Left
  tft.fillTriangle(215, 480, 235, 440, 255, 480, RED); //outside temp section Right
  tft.fillRect(85, 440, 150, 5, RED); //outside temp top line
  tft.fillTriangle(70, 480, 88, 445, 110, 480, BGCOLOR); //outside temp section Left empty
  tft.fillTriangle(210, 480, 232, 445, 250, 480, BGCOLOR); //outside temp section Right empty
  sensors.requestTemperatures();
  float temperatureInCelsius = sensors.getTempCByIndex(SENSOR_INDEX);
  dtostrf(temperatureInCelsius, 4, 1, currenttemp);
  strcat(tempstring, currenttemp);
  strcat(tempstring, " C");
  showmsgXY(160, 462, 1, 5, FSSB18, tempstring);
  oldtemp = temperatureInCelsius;
  LCDMutex = xSemaphoreCreateMutex();    
  xTaskCreatePinnedToCore(
                    PrintCRNTGearCode, 
                    "PrintCRNTGear", 
                    10000,
                    NULL, 
                    1, 
                    &PrintCRNTGear,
                    1);
  delay(10);                      
  xTaskCreate(
                    TempSensorCode,   /* Task function. */
                    "TempSensor",     /* name of task. */
                    3000,       /* Stack size of task --has about 2000 spare--*/
                    NULL,        /* parameter of the task */
                    1,           /* priority of the task */
                    &TempSensor);              
  delay(10);                              
  xTaskCreate(
                    WasherTaskCode,   /* Task function. */
                    "WasherTask",     /* name of task. */
                    4000,       /* Stack size of task --has about 3300 spare--*/
                    NULL,        /* parameter of the task */
                    1,           /* priority of the task */
                    &WasherTask);                      
  delay(10);
  xTaskCreate(
                    FuelCode,   /* Task function. */
                    "Fuel",     /* name of task. */
                    10000,       /* Stack size of task */
                    NULL,        /* parameter of the task */
                    1,           /* priority of the task */
                    &Fuel);      /* Task handle to keep track of created task */
  delay(10);          
  xTaskCreate(
                    CoolantCode,   /* Task function. */
                    "Coolant",     /* name of task. */
                    10000,       /* Stack size of task */
                    NULL,        /* parameter of the task */
                    1,           /* priority of the task */
                    &Coolant);      /* Task handle to keep track of created task */
  delay(10);         
  xTaskCreate(
                    WarningTaskCode,   /* Task function. */
                    "WarningTask",     /* name of task. */
                    6000,       /* Stack size of task */
                    NULL,        /* parameter of the task */
                    1,           /* priority of the task */
                    &WarningTask);      /* Task handle to keep track of created task */
  delay(10);     
  xTaskCreate(
                    TPMSCode,   /* Task function. */
                    "TPMS",     /* name of task. */
                    10000,       /* Stack size of task */
                    NULL,        /* parameter of the task */
                    1,           /* priority of the task */
                    &TPMS);      /* Task handle to keep track of created task */
  delay(10);
  vTaskDelay(50);
  ledcAttach(LEDPin, LEDFreq, LEDRes);
  ledcWrite(LEDPin, LEDDuty); //turn backlight back on
}

void PrintCRNTGearCode(void * pvParameters){
  for(;;)
  {
  GearBut1.loop(); //ezbutton loops
  GearBut2.loop();
  GearBut3.loop();
  GearBut4.loop();
  GearButRev.loop();
  if ((GearBut1.getState() == 0) && (GEAR != 1))
    {   
      delay(50);
      xSemaphoreTake(LCDMutex, portMAX_DELAY);
      showmsgXY(160, 310, 2, 100, FSSB24, "1");
      GEAR = 1;
      geartimer = millis();
      xSemaphoreGive(LCDMutex); // release mutex
      Serial.println("1");
    }

  else if ((GearBut2.getState() == 0) && (GEAR != 2))
    {
      xSemaphoreTake(LCDMutex, portMAX_DELAY);
      showmsgXY(160, 310, 2, 100, FSSB24, "2");        
      GEAR = 2;
      geartimer = millis();      
      xSemaphoreGive(LCDMutex); // release mutex
      Serial.println("2");
    }

  else if ((GearBut3.getState()== 0) && (GEAR != 3))
    {
      xSemaphoreTake(LCDMutex, portMAX_DELAY);      
      showmsgXY(160, 310, 2, 100, FSSB24, "3");      
      GEAR = 3;
      geartimer = millis();
      xSemaphoreGive(LCDMutex); // release mutex
      Serial.println("3");
    }

  else if ((GearBut4.getState() == 0) && (GEAR != 4))
    {
      xSemaphoreTake(LCDMutex, portMAX_DELAY);      
      showmsgXY(160, 310, 2, 100, FSSB24, "4");      
      GEAR = 4;
      geartimer = millis();
      xSemaphoreGive(LCDMutex); // release mutex
      Serial.println("4");
    }

  else if ((GearButRev.getState() == 0) && (GEAR != 5))
    {
      xSemaphoreTake(LCDMutex, portMAX_DELAY);
      showmsgXY(160, 310, 2, 100, FSSB24, "R");      
      GEAR = 5;
      geartimer = millis();
      xSemaphoreGive(LCDMutex); // release mutex
      Serial.println("R");
    }

  else if ((GearBut1.getState() == 1) && (GearBut2.getState() == 1) && (GearBut3.getState() == 1) && (GearBut4.getState() == 1) && (GearButRev.getState() == 1) && (GEAR != 0))
    {
      if ((millis()) >= (geartimer + 1400))
        {
        xSemaphoreTake(LCDMutex, portMAX_DELAY);      
        showmsgXY(160, 310, 2, 100, FSSB24, "N");            
        GEAR = 0; 
        xSemaphoreGive(LCDMutex); // release mutex
        Serial.println("N");
        }
    }
  else
    {
      geartimer = millis();
    }
  
    //vTaskDelay(100);  
    }
}

void FuelCode(void * pvParameters){
  for(;;)
  {
  FuelTotal = FuelTotal - FuelArray[FuelIndex];
  FuelArray[FuelIndex] = (analogReadMilliVolts(FuelPin)*0.977);//1125 eFuse, multiplied to adjust voltage reading.
  FuelTotal = FuelTotal + FuelArray[FuelIndex];
  FuelIndex += 1;
  if (FuelIndex >= 32)
    {
      FuelIndex = 0;
    }
  FuelAverage = FuelTotal / 32;
  if (FuelAverage >= FuelCurrent + 6 || FuelAverage <= FuelCurrent - 6)
    {
      FuelCurrent = FuelAverage;
      float FuelBarSIZE = multiMap<float>(FuelCurrent, FuelValuesIN, FuelValuesOUT, 11); //constrains value automatically
      Serial.println(FuelBarSIZE);
      xSemaphoreTake(LCDMutex, portMAX_DELAY);
      tft.fillRect(280, 210, 25, 210 - FuelBarSIZE, BGCOLOR); //empty bar to new level
      tft.fillRect(280, 420 - FuelBarSIZE, 25, FuelBarSIZE, ORANGE); //fill bar to new fuel level mapped
      xSemaphoreGive(LCDMutex);
    }
  vTaskDelay(1000);    
  } 
}


//coolant reading might need to be mapped differently, as its not linear. Update range might need to be different
//than 10 as well, 10 is fine for upper ranges, but at low temp it would update constantly. Might be an issue on highway
//driving and stopping lots might make level update too often, add some dampening maybe? so it grows the bar a little slower when warming up. 
//ALSO. Using 210 ohm and 20 ohm divider, brings voltage low but a little too low. Overheating temps too accurate compared to proper running temps,
//should bring voltage up to about 2v, right now overheating 35ohm (300c) is at 1.1 ish. Need 2 watt resistors to be safe
//60 reading is about 69 celcius right now,

//OKAY. 1000 on R1 resister, 47 on second one (inline with thermistor). Could do other values, but this feels okay.
//Fiero Gauge shows 100F lowest, 220f middle, and 260f highest (end of red overheating).

//lots of the above might be wrong now, as im putting 3.16v (on this specific board) to the sensor rather than 12v.
void CoolantCode(void * pvParameters){
  for(;;)
  {
  //Serial.println();
  //Serial.println(analogRead(CoolantPin));
  //Serial.println(analogReadMilliVolts(CoolantPin));
  CoolantTotal = CoolantTotal - CoolantArray[CoolantIndex];
  CoolantArray[CoolantIndex] = (analogReadMilliVolts(CoolantPin)*0.977);
  CoolantTotal = CoolantTotal + CoolantArray[CoolantIndex];
  CoolantIndex += 1;
  if (CoolantIndex >= 32)
    {
      CoolantIndex = 0;
    }
  CoolantAverage = CoolantTotal / 32;
  if (CoolantAverage >= CoolantCurrent + 6 || CoolantAverage <= CoolantCurrent - 6)
    {
      CoolantCurrent = CoolantAverage; ///need to get array temp values, and interpolate between the Fahrenheit. THEN map that value to the FuelBarSIZE.
      float CoolantBarSIZE = multiMap<float>(CoolantCurrent, CoolantValuesIN, CoolantValuesOUT, 29); //constrains value automatically
      Serial.print("COOLANT BAR SIZE AFTER MULTIMAP");
      Serial.println(CoolantBarSIZE);      
      CoolantBarSIZE = map(constrain(CoolantBarSIZE, 100, 260), 100, 260, 0, 210); //constrain Fahrenheit to 0-210 pixels for bar.
      xSemaphoreTake(LCDMutex, portMAX_DELAY);
      tft.fillRect(15, 205, 25, 210 - CoolantBarSIZE, BGCOLOR); //empty bar to new level
      tft.fillRect(15, 420 - CoolantBarSIZE, 25, CoolantBarSIZE, ORANGE); //fill bar to new Coolant level mapped
      xSemaphoreGive(LCDMutex);
      Serial.print("COOLANT BAR SIZE PRINTING");
      Serial.println(CoolantBarSIZE);
    }
  //Serial.println(CoolantCurrent);
  vTaskDelay(1000);
  } 
}

//do case, 1 to 3. loop through one at a time, every 10 seconds? So if wiper fluid low, and tire low, and its cold outside, alternate data shown.
void WarningTaskCode(void * pvParameters){
  for(;;)
  {
    if (washerlow == true)
      {
        xSemaphoreTake(LCDMutex, portMAX_DELAY);
        showmsgXY(160, 135, 1, 100, FSSB12, "WASHER LOW");
        tft.drawBitmap(142, 60, wiper, 50, 50, RED);
        xSemaphoreGive(LCDMutex);
        LastPrintWARN = 1;
      }
    else
      {
        xSemaphoreTake(LCDMutex, portMAX_DELAY);
        //tft.fillRect(0, 60, 320, 95, BGCOLOR);
        xSemaphoreGive(LCDMutex);
        LastPrintWARN = 0;
      }
  vTaskDelay(1000);       
  }    
} 

void WasherTaskCode(void * pvParameters){
  for(;;)
  {
    if (WasherIndex == 15)
      {
        WasherArray[WasherIndex] = (digitalRead(WasherLVL));
        WasherIndex = 0;
        WasherCount += (digitalRead(WasherLVL));
        if ((WasherCount <= 5) && (washerlow == false))
          {
            WasherCount = 0;
            washerlow = true;
          }
        else if ((WasherCount > 5) && (washerlow == true))
          {
            WasherCount = 0;
            washerlow = false;
          }
        else
          {
            //nothing
          }
      }
    else 
      {
        WasherArray[WasherIndex] = (digitalRead(WasherLVL));
        WasherIndex += 1;
        WasherCount += (digitalRead(WasherLVL));
      }    
    vTaskDelay(1000);
  }       
} 

void TPMSCode (void * pvParameters){
  for(;;){
  Serial.println("TPMS STUFF TO DO");
  vTaskDelay(2000);
  }
}

void TempSensorCode(void * pvParameters){
  for(;;)
  {
  sensors.requestTemperatures();
  float temperatureInCelsius = sensors.getTempCByIndex(SENSOR_INDEX);
 // float temperatureInFahrenheit = sensors.getTempFByIndex(SENSOR_INDEX);
  if (oldtemp != temperatureInCelsius)
    {
      xSemaphoreTake(LCDMutex, portMAX_DELAY);
      dtostrf(temperatureInCelsius, 9 , 1, currenttemp);
      showmsgXY(213, 24, 1, 70, FSSB18, currenttemp);
      xSemaphoreGive(LCDMutex);
      oldtemp = temperatureInCelsius;
    }
  vTaskDelay(2000); // 2 second delay on checking outside temp. Preeeetty sure other tasks on core 2 still run?
  }
}

void loop() {vTaskDelete(NULL);} // disable main loop